# 练习一
## 理解内核级信号量的实现和基于内核级信号量的哲学家就餐问题

通过meld查看lab6和修改后的lab7不同之处。

发现原来lab6中使用lock进行的互斥操作变成了使用信号量sem的互斥操作。

并且lab7中实现了等待队列、计时器、禁用中断等互斥操作底层支撑。

semaphore的几个操作包括up、down和try down，在结构体中包含一个value，以及一个wait_queue等待队列。

#### 请在实验报告中给出内核级信号量的设计描述，并说其大致执行流流程。

在ucore中文件sem.c和sem.h实现了信号量。它的数据结构和函数功能如下：

```
typedef struct {    int value;    wait_queue_t wait_queue;} semaphore_t;void sem_init(semaphore_t *sem, int value);void up(semaphore_t *sem);void down(semaphore_t *sem);bool try_down(semaphore_t *sem);
```

其中包括了value和wait_queue两个成员变量，以及up和down两个主要函数。

对于up函数，首先禁用中断，然后检查如果等待队列为空，那么将value值加一，否则直接唤醒一个等待进程，最后进行恢复中断操作。

对于down函数，首先屏蔽中断。如果value的值大于0，那么直接将其减一，然后恢复中断后退出。如果value值小于0，恢复中断，那么将当前进程加入到等待队列中，然后唤醒一个其他进程开始运行。直到该进程再次被唤醒，先屏蔽中断，将其从等待队列中删除，最后恢复中断。

#### 请在实验报告中给出给用户态进程/线程提供信号量机制的设计方案，并比较说明给内核级提供信号量机制的异同。
对于用户态进程／线程的信号量，信号量的各项操作都会转换为系统调用，在内核中会有一个信号量与之对应。每当用户进程调用信号量相关函数时，都会进入系统调用，由操作系统内核进行处理，之后再返回到用户态开始执行。

不同：用户态需要使用内核态信号量机制，并且在使用时进行系统调用。