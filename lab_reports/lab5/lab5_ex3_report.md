# 练习三 阅读分析源代码，理解进程执行 fork/exec/wait/exit 的实现，以及系统调用的实现
#### do_fork的主要工作流程
1. 分配并初始化进程控制块（alloc_proc函数）；

2. 分配并初始化内核栈（setup_stack函数）；

3. 根据clone_flag标志复制或共享进程内存管理结构（copy_mm函数）；

4. 设置进程在内核（将来也包括用户态）正常运行和调度所需的中断帧和执行上下文（copy_thread函数）；

5. 把设置好的进程控制块放入hash_list和proc_list两个全局进程链表中；

6. 自此，进程已经准备好执行了，把进程状态设置为“就绪”态；

7. 设置返回码为子进程的id号。

#### do_exec的主要工作流程
- 首先为加载新的执行码做好用户态内存空间清空准备。如果mm不为NULL，则设置页表为内核空间页表，且进一步判断mm的引用计数减1后是否为0，如果为0，则表明没有进程再需要此进程所占用的内存空间，为此将根据mm中的记录，释放进程所占用户空间内存和进程页表本身所占空间。最后把当前进程的mm内存管理指针为空。
- 接下来的一步是加载应用程序执行码到当前进程的新创建的用户态虚拟空间中。这里涉及到读ELF格式的文件，申请内存空间，建立用户态虚存空间，加载应用程序执行码等。load_icode函数完成了整个复杂的工作。

#### do_wait的主要工作流程
1. 如果pid!=0，表示只找一个进程id号为pid的退出状态的子进程，否则找任意一个处于退出状态的子进程。

2. 如果此子进程的执行状态不为PROC_ZOMBIE，表明此子进程还没有退出，则当前进程只好设置自己的执行状态为PROC_SLEEPING，睡眠原因为WT_CHILD（即等待子进程退出），调用schedule()函数选择新的进程执行，自己睡眠等待，如果被唤醒，则重复跳回步骤1处执行。

3. 如果此子进程的执行状态为PROC_ZOMBIE，表明此子进程处于退出状态，需要当前进程（即子进程的父进程）完成对子进程的最终回收工作，即首先把子进程控制块从两个进程队列proc_list和hash_list中删除，并释放子进程的内核堆栈和进程控制块。自此，子进程才彻底地结束了它的执行过程，消除了它所占用的所有资源。

#### do_exit的主要工作流程

1. 如果current->mm != NULL，表示是用户进程，则开始回收此用户进程所占用的用户态虚拟内存空间。

2. 这时，设置当前进程的执行状态current->state=PROC_ZOMBIE，当前进程的退出码current->exit_code=error_code。此时当前进程已经不能被调度了，需要此进程的父进程来做最后的回收工作（即回收描述此进程的内核栈和进程控制块）。

3. 如果当前进程的父进程current->parent处于等待子进程状态：current->parent->wait_state==WT_CHILD，则唤醒父进程（即执行“wakup_proc(current->parent)”），让父进程帮助自己完成最后的资源回收。

4. 如果当前进程还有子进程，则需要把这些子进程的父进程指针设置为内核线程initproc，且各个子进程指针需要插入到initproc的子进程链表中。如果某个子进程的执行状态是PROC_ZOMBIE，则需要唤醒initproc来完成对此子进程的最后回收工作。

5. 执行schedule()函数，选择新的进程执行。

## 思考题
#### 请分析fork/exec/wait/exit在实现中是如何影响进程的执行状态的？

fork之后会讲进程的运行状态设置为RUNNABLE。

wait时如果找到一个状态为ZOMBIE的进程，那么将其内存空间释放；如果找不到，那么状态变为SLEEPING，进行进程调度。

exit时进程会在回收完自己的内存空间后将自己状态设置为ZOMBIE。

#### 请给出ucore中一个用户态进程的执行状态生命周期图（包执行状态，执行状态之间的变换关系，以及产生变换的事件或函数调用）。（字符方式画即可）
```
fork ————> wakeup ————> RUNNABLE ————> 进程执行 ————> 进程结束 ————> exit ————> ZOMBIE ————> 父进程回收进程结束
			|		|					|		|
			|<—— schedule —>| 					|—— 父进程找到 ——>|
										|
										|
										|—— 父进程找不到待回收子进程 ————> SLEEPING
```