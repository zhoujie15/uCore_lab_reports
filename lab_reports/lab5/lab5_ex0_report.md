# 练习零
## 填写已有实验

本实验依赖实验1/2/3/4。请把你做的实验1/2/3/4的代码填入本实验中代码中有“LAB1”/“LAB2”/“LAB3”/“LAB4”的注释相应部分。注意：为了能够正确执行lab5的测试应用程序，可能需对已完成的实验1/2/3/4的代码进行进一步改进。

和之前的实验不同，此次实验需要根据需要对前四个实验的代码进行修改。

根据代码中的注释进行相应的修改。主要有以下几处。

LAB1: 增加中断门，让用户态程序能够进行系统调用。
```
voididt_init(void) {     /* LAB1 YOUR CODE : STEP 2 */     /* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?      *     All ISR's entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c      *     (try "make" command in lab1, then you will find vector.S in kern/trap DIR)      *     You can use  "extern uintptr_t __vectors[];" to define this extern variable which will be used later.      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).      *     Can you see idt[256] in this file? Yes, it's IDT! you can use SETGATE macro to setup each item of IDT      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using 'lidt' instruction.      *     You don't know the meaning of this instruction? just google it! and check the libs/x86.h to know more.      *     Notice: the argument of lidt is idt_pd. try to find it!      */     /* LAB5 YOUR CODE */      //you should update your lab1 code (just add ONE or TWO lines of code), let user app to use syscall to get the service of ucore     //so you should setup the syscall interrupt gate in here    extern uintptr_t __vectors[];    int i;    for (i = 0; i < sizeof(idt) / sizeof(struct gatedesc); i ++) {        SETGATE(idt[i], 0, GD_KTEXT, __vectors[i], DPL_KERNEL);    }    SETGATE(idt[T_SYSCALL], 1, GD_KTEXT, __vectors[T_SYSCALL], DPL_USER);    lidt(&idt_pd);}
```

LAB1: 在这里更改对于时钟中断的处理，每当到一个时间片结束，将当前进程的need_resched设置为1，表示需要进行进程切换。这里注意必须要去掉之前的print_ticks()语句，否则make grade检查过程中会出错。

```
    /* LAB1 YOUR CODE : STEP 3 */        /* handle the timer interrupt */        /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().         * (3) Too Simple? Yes, I think so!         */        /* LAB5 YOUR CODE */        /* you should upate you lab1 code (just add ONE or TWO lines of code):         *    Every TICK_NUM cycle, you should set current process's current->need_resched = 1         */        ticks ++;        if (ticks % TICK_NUM == 0) {            current->need_resched = 1;        }        break;
```

LAB4: 更新PCB中新增添的成员变量的初始值。主要有wait_state, cptr, yptr, optr。
```
// alloc_proc - alloc a proc_struct and init all fields of proc_structstatic struct proc_struct *alloc_proc(void) {    struct proc_struct *proc = kmalloc(sizeof(struct proc_struct));    if (proc != NULL) {    //LAB4:EXERCISE1 2012011394    /*     * below fields in proc_struct need to be initialized     *       enum proc_state state;                      // Process state     *       int pid;                                    // Process ID     *       int runs;                                   // the running times of Proces     *       uintptr_t kstack;                           // Process kernel stack     *       volatile bool need_resched;                 // bool value: need to be rescheduled to release CPU?     *       struct proc_struct *parent;                 // the parent process     *       struct mm_struct *mm;                       // Process's memory management field     *       struct context context;                     // Switch here to run process     *       struct trapframe *tf;                       // Trap frame for current interrupt     *       uintptr_t cr3;                              // CR3 register: the base addr of Page Directroy Table(PDT)     *       uint32_t flags;                             // Process flag     *       char name[PROC_NAME_LEN + 1];               // Process name     */    	proc->state = PROC_UNINIT;    	proc->pid = -1;    	proc->runs = 0;    	proc->kstack = 0;    	proc->need_resched = 0;    	proc->parent = NULL;    	proc->mm = NULL;    	memset(&(proc->context), 0, sizeof(struct context));    	proc->tf = NULL;    	proc->cr3 = boot_cr3;    	proc->flags = 0;    	proc->wait_state = 0;    	proc->cptr = NULL;    	proc->yptr = NULL;    	proc->optr = NULL;    	memset(proc->name, 0, PROC_NAME_LEN);     //LAB5 YOUR CODE : (update LAB4 steps)    /*     * below fields(add in LAB5) in proc_struct need to be initialized	     *       uint32_t wait_state;                        // waiting state     *       struct proc_struct *cptr, *yptr, *optr;     // relations between processes	 */    }    return proc;}
```
LAB4: 更新do_fork函数，主要更新其中的第一步和第五步，设置parent，调用set_links函数，函数中包含了之前的一些操作，这里需要去掉。

```
intdo_fork(uint32_t clone_flags, uintptr_t stack, struct trapframe *tf) {    int ret = -E_NO_FREE_PROC;    struct proc_struct *proc;    if (nr_process >= MAX_PROCESS) {        goto fork_out;    }    ret = -E_NO_MEM;    //LAB4:EXERCISE2 2012011394    /*     * Some Useful MACROs, Functions and DEFINEs, you can use them in below implementation.     * MACROs or Functions:     *   alloc_proc:   create a proc struct and init fields (lab4:exercise1)     *   setup_kstack: alloc pages with size KSTACKPAGE as process kernel stack     *   copy_mm:      process "proc" duplicate OR share process "current"'s mm according clone_flags     *                 if clone_flags & CLONE_VM, then "share" ; else "duplicate"     *   copy_thread:  setup the trapframe on the  process's kernel stack top and     *                 setup the kernel entry point and stack of process     *   hash_proc:    add proc into proc hash_list     *   get_pid:      alloc a unique pid for process     *   wakup_proc:   set proc->state = PROC_RUNNABLE     * VARIABLES:     *   proc_list:    the process set's list     *   nr_process:   the number of process set     */    if ((proc = alloc_proc()) == NULL){		// 1. call alloc_proc to allocate a proc_struct    	goto fork_out;    }    proc->parent = current;    assert(current->wait_state == 0);    if (setup_kstack(proc) != 0){	    	// 2. call setup_kstack to allocate a kernel stack for child process    	goto bad_fork_cleanup_proc;    }    if (copy_mm(clone_flags, proc) != 0){ 	// 3. call copy_mm to dup OR share mm according clone_flag    	goto bad_fork_cleanup_kstack;    }	copy_thread(proc, stack, tf); 			// 4. call copy_thread to setup tf & context in proc_struct	bool intr_flag;	local_intr_save(intr_flag);{    	proc->pid = get_pid();    	hash_proc(proc);						// 5. insert proc_struct into hash_list && proc_list    //list_add(&proc_list, &(proc->list_link));    //nr_process ++;		set_links(proc);	}	local_intr_restore(intr_flag);    wakeup_proc(proc);						// 6. call wakup_proc to make the new child process RUNNABLE    ret = proc->pid;						// 7. set ret vaule using child proc's pid	//LAB5 YOUR CODE : (update LAB4 steps)   /* Some Functions    *    set_links:  set the relation links of process.  ALSO SEE: remove_links:  lean the relation links of process     *    -------------------	*    update step 1: set child proc's parent to current process, make sure current process's wait_state is 0	*    update step 5: insert proc_struct into hash_list && proc_list, set the relation links of process    */	fork_out:    return ret;bad_fork_cleanup_kstack:    put_kstack(proc);bad_fork_cleanup_proc:    kfree(proc);    goto fork_out;}
```
